# Chapter 03 명령어

## 03-1 소스 코드와 명령어

### 고급 언어와 저급 언어

#### 고급 언어
- C, C++, Java, Python과 같은 프로그래밍 언어
- 사람을 위한 언어

#### 저급 언어
- 컴퓨터가 직접 이해하고 실행할 수 있는 언어
- 저급 언어에는 기계어와 어셈블리어가 있다.
- 기계어: 0과 1의 명령어 비트로 이루어진 언어
- 어셈블리어: 기계어를 읽기 편한 형태로 번역한 언어
- 하드웨어 관련 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 정보 보안 분야 등의 개발자는 어셈블리어를 많이 이용하게 됨.

### 컴파일 언어와 인터프리터 언어

고급 언어가 저급 언어로 변환되는 방식에 따라 **컴파일 언어**와 **인터프리터 언어**로 분류된다.

#### 컴파일 언어
- 소스 코드 전체가 저급 언어로 변환됨
- 이 과정을 **컴파일**이라고 하고, 컴파일을 수행해 주는 도구를 **컴파일러**라고 함
- 컴파일러를 통해 저급 언어로 변환된 코드를 **목적 코드**라고 함
- C

#### 인터프리터 언어
- 소스 코드가 한 줄씩 실행됨
- **인터프리터**가 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해줌
- Python

#### 차이점
- 컴파일 언어는 소스 코드 내에 오류가 하나라도 있으면 컴파일이 불가능하지만 인터프리터 언어는 소스 코드 N번째 줄에 오류가 있더라도 N-1번째 줄까지는 올바르게 수행된다.
- 일반적으로 인터프리터 언어가 컴파일 언어보다 느리다.
- (컴파일 시간을 기다려야 하지만) 컴파일을 통해 나온 목적 코드는 _저급 언어_ 인 반면 인터프리터 언어는 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문

<br>
⭐️ 사실 컴파일 언어와 인터프리터 언어 간의 경계는 모호하다. <br> 👉 Python도 컴파일함, Java는 컴파일과 인터프리트를 동시에 수행함

<br>
⭐️ 목적 파일과 실행 파일은 다르다. <br> 👉 목적 파일은 목적 코드로 이루어져 있지만 목적 코드가 실행 파일이 되기 위해서는 목적 코드에 명시된 외부 기능을 연결짓는 링킹 작업을 거쳐야 한다. <br> <br>

## 03-2 명령어의 구조

### 연산 코드와 오퍼랜드
명령어는 연산 코드와 오퍼랜드로 구성되어 있다.
|연산 코드|오퍼랜드|
|----|---|
|연산자|피연산자|
|명령어가 수행할 연산|'연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치'|
|빼라|메모리 32번지 안의 값과, 메모리 33번지 안의 값을|

#### 오퍼랜드
- 오퍼랜드 필드는 **주소 필드**라고도 한다.
- 데이터를 직접 명시하기보다는 메모리 주소나 레지스터 이름이 담기게 됨
- 오퍼랜드 개수에 따라 _0-주소 명령어_, _1-주소 명령어_, _2-주소 명령어_, _3-주소 명령어_ 가 됨

#### 연산 코드

가장 기본적인 연산 코드 유형은 1. 데이터 전송, 2.산술/논리 연산, 3. 제어 흐름 변경, 4. 입출력 제어로 나눌 수 있다.

##### 데이터 전송
- MOVE: 데이터를 옮겨라
- STORE: 메모리에 저장하라
- LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
- PUSH: 스택에 데이터를 저장하라
- POP: 스택의 최상단 데이터를 가져와라

##### 산술/논리 연산
- ADD/SUBTRACT/MULTIPLY/DIVIDE: 사칙연산 수행
- INCREMENT/DECREMENT: 오퍼랜드에 1을 더하라/1을 빼라
- AND/OR/NOT: AND/OR/NOT 연산 수행
- COMPARE: 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라

##### 제어 흐름 변경
- JUMP: 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT: 프로그램의 실행을 멈춰라
- CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라
<br>❗️ CALL과 RETURN은 함수를 호출하고 리턴하는 명령어

##### 입출력 제어
- READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
- START IO: 입출력 장치를 시작하라
- TEST IO: 입출력 장치의 상태를 확인하라

<br>

### 주소 지정 방식

#### 하나의 명령어가 n비트, 그 중 연산 코드 필드가 m비트라고 가정했을 때
##### 오퍼랜드 필드에 _데이터_ 를 담으면
- 오퍼랜드 필드의 길이는 1-주소 명령어라 할지라도 n-m비트
##### 오퍼랜드 필드에 _주소_ 를 담으면
- 표현할 수 있는 데이터의 크기는 하나의 메모리 주소(or 레지스터)에 저장할 수 있는 공간만큼 커짐

#### 유효 주소
- 유효 주소: 연산의 대상이 되는 데이터가 저장된 위치
- 주소 지정 방식: 유효 주소를 찾는 방법
- 주소 지정 방식에는 즉시 주소 지정 방식, 직접 주소 지정 방식, 간접 주소 지정 방식, 레지스터 주소 지정 방식, 레지스터 간접 주소 지정 방식이 있다.

#### 주소 지정 방식
각각의 방식이 오퍼랜드 필드에 명시하는 값
- 즉시 주소 지정 방식: 연산에 사용할 데이터
- 직접 주소 지정 방식: 유효 주소(메모리 주소)
- 간접 주소 지정 방식: 유효 주소의 주소
<br>❗️두 번의 메모리 접근이 필요하기 때문에 느림
- 레지스터 주소 지정 방식: 유효 주소(레지스터 이름)
- 레지스터 간접 주소 지정 방식: 유효 주소를 저장한 레지스터
<br>❗️메모리에 접근하는 것이 레지스터에 접근하는 것보다 느리기 때문에 간접 주소 지정 방식보다는 빠름

<br>

### 스택과 큐
#### ✔️ 스택, 후입선출(LIFO), PUSH, POP
#### ✔️ 큐, 선입선출(FIFO)


