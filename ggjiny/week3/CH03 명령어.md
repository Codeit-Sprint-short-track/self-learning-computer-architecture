# Ch03 명령어

# 03-1 소스코드와 명령어

## 고급 언어와 저급 언어

### 고급 언어

- 프로그래밍 언어와 같이 사람을 위한 언어

### 저급 언어

- 컴퓨터가 직접 이해하고 실행할 수 있는 언어
- 명령어로 이루어짐
- 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급언어(명령어)로 변환되어야 함
- 고급언어 → 저급언어

### 저급언어의 두 가지 종류

- 기계어: 0과 1로 이루어진 명령어 모음
  - 이진수, 십육진수로 표현
  - 오로지 컴퓨터만을 위해 만들어진 언어이므로 사람이 이해하기 어려움
- 어셈블리어: 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 언어
  - 이를 통해 컴퓨터가 프로그램을 어떤 과정으로 실행하는지, 프로그램이 어떤 절차로 작동하는지 가장 근본적인 단계에서부터 하나하나 추적하고 관찰할 수 있음

## 컴파일 언어와 인터프리터 언어

고급 언어가 저급 언어로 변화되는 방식

### 컴파일 언어

- 컴파일 방식으로 작동하는 프로그래밍 언어
- 컴파일러에 의해 소스코드 전체가 저급 언어로 변환되어 실행됨
- 대표적인 컴파일 언어 → C

컴파일: 컴파일 언어로 작성된 소스 코드 전체가 저급 언어로 변환되는 과정

컴파일러: 컴파일을 수행해 주는 도구

- 개발자가 작성한 코드 전체를 훑어보며 문법적인 오류는 없는지, 실행 간으한 코드인지, 실행하는데 불필요한 코드는 없는지 따지며 저급 언어로 컴파일
- 오류를 발견하면 컴파일에 실패
- 컴파일이 성공적으로 수행되면 소스코드는 저급언어로 변환됨, 변환된 코드 ⇒ 목적 코드(Object code)

### 인터프리터 언어

- 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
- 대표적인 인터프리터 언어 → Python
- 소스 코드 전체가 저급 언어로 변환되는 컴파일 언어와 달리 소스코드를 한 줄씩 차례로 실행
- 인터프리터: 한 줄씩 저급언어로 변환하여 실행해주는 도구
- 한 줄씩 실행하기 때문에 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요 없음
- 소스 코드 내에 오류가 하나라도 있으면 컴파일이 불가능했던 컴파일 언어와는 달리, 소스 코드 N번째 줄에 문법 오류가 있더라도 N-1번째까지 올바르게 수행됨

⇒ 인터프리터 언어는 컴파일 언어보다 느림. 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 저급 언어인 반면, 인터프리터 언어는 소스 코드 마지막에 이를때까지 한 줄씩 저급 언어로 해석하며 실행해야하기 때문

# 03-2 명령어의 구조

## 연산 코드와 오퍼랜드

명령어: 연산 코드와 오퍼랜드로 구성되어 있음

연산 코드(operation code): 명령어가 수행할 연산 → 연산자

오퍼랜드(operand): 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치 → 피연산자

연산 코드 필드: 연산 코드가 담기는 영역

오퍼랜드 필드: 오퍼랜드가 담기는 영역

### 오퍼랜드

- 오퍼랜드 필드에는 숫자나 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있음
- 오퍼랜드 필드에는 연산에 사용할 데이터를 직접 명시하기 보단 많은 경우 사용할 데이터가 저장된 위치를 명시, 즉 메모리 주소나 레지스터 이름이 담김
  - 오퍼랜드 필드 === **주소 필드**

오퍼랜드의 개수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어라고 함

### 연산 코드

4가지 유형

1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

## 주소 지정 방식

유효 주소

- 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치

**주소 지정 방식**

- 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 **연산에 사용할 데이터 위치를 찾는 방법**
- 유효 주소를 찾는 방법
- 대표적인 5가지 방식

### 즉시 주소 지정 방식

- **연산에 사용할 데이터**를 오퍼랜드 필드에 직접 명시
- 가장 간단한 형태
- 표현할 수 있는 데이터의 크기가 작아지는 단점
- 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 빠름

### 직접 주소 지정 방식

- 오퍼랜드 필드에 **유효 주소**를 직접적으로 명시하는 방식
- 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어듦
- 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있음

### 간접 주소 지정 방식

- **유효 주소의 주소**를 오퍼랜드 필드에 명시
- 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓어짐
- 두 번의 메모리 접근이 필요하기 때문에 앞의 주소 지정 방식들보다 일반적으로 느림

### 레지스터 주소 지정 방식

- 직접 주소 지정 방식과 비슷하게 **연산에 사용할 데이터를 저장한 레지스터**를 오퍼랜드 필드에 직접 명시
- 일반저긍로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름
- 직접 주소 지정 방식보다 빠르게 데이터에 접근
- 직접 주소 지정 방식과 비슷한 문제, 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음

### 레지스터 간접 주소 지정 방식

- 연산에 사용할 데이터를 메모리에 저장하고, 그 **주소(유효 주소)를 저장한 레지스터**를 오퍼랜드 필드에 명시
- 유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷
- 메모리에 접근하는 횟수가 한번으로 줄어드는 장점
- 메모리에 접근한느 것이 레지스터에 접근하는 것보다 더 느르기 때문에 간접 주소 지정 방식보다 빠름
