# Ch04 CPU의 작동 원리

# 04-1 ALU와 제어 장치

## ALU

- 연산한 결괏값과 플래그를 내보냄
- 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들임
  - 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들임
- 산술 연산, 논리 연산 등 다양한 연산 수행

CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느림

⇒ ALU의 결괏값을 메모리가 아닌 레지스터에 우선 저장

### 플래그

- 연산 결과에 대한 추가적인 상태 정보
- 부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그
  - 오버플로우: 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황
- 플래그 레지스터에 저장됨

## 제어장치

제어장치: 제어 신호를 내보내고, 명령어를 해석하는 부품

제어 신호: 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

### 제어 장치가 받아들이는 정보

1. 클럭 신호
   - 클럭 clock: 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
   - 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어들임
2. 해석해야 할 명령어
   - CPU가 해석해야할 명령어는 명령어 레지스터에 저장됨
   - 제어 장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한뒤 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려줌
3. 플래그 레지스터 속 플래그 값
   - 플래그는 ALU 연산에 대한 추가적인 상태 정보
   - 제어장치가 제어 신호를 통해 컴퓨터 부품들을 제어할 때 이 중요한 참고 사항을 무시하면 안되기 때문에 이를 참고해 제어 신호를 발생시킴
4. 시스템 버그, 그중에서 제어 버스로 전달된 제어 신호
   - 제어 신호는 CPU 뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있음

### 제어장치가 내보내는 정보

CPU 외부에 전달하는 제어 신호와 CPU 내부에 전달하는 제어 신호

- 제어장치가 **CPU 외부**에 제어 신호를 전달한다는 말은 곧, 제어 버스로 제어 신호를 내보낸다는 말과 같음
  - 메모리에 전달하는 제어 신호, 입출력장치에 전달하는 제어 신호
- 제어장치가 CPU 내부에 전달하는 제어 신호에는 ALU에 전달하는 제어 신호와 레지스터에 전달하는 제어 신호

---

# 04-2 레지스터

레지스터만 잘 관찰해도 프로그램의 자세한 실행 과정을 알 수 있음

레지스터는 CPU 내에 있는 작은 임시 저장 장치

## **반드시 알아야 할 8개의 레지스터**

- 프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터, 범용 레지스터, 플래그 레지스터, 스택 포인터, 베이스 레지스터

### 프로그램 카운터

- 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소 저장
- 명령어 포인터(IP: Instruction Pointer)라고 부르는 CPU도 있음

### 명령어 레지스터

- 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터
- 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어신호를 내보냄

### 메모리 주소 레지스터

- 메모리의 주소를 저장하는 레지스터
- CPU가 읽어들이고자하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침

### 메모리 버퍼 레지스터

- 메모리와 주고 받을 값(데이터와 명령어)을 저장하는 레지스터
- 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거침
- CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거침
- 메모리 데이터 레지스터라고도 불림

### 실행 과정

1. CPU로 실행할 프로그램이 1000번지부터 1500번지까지 저장되어있다고 가정. 1000번지에는 1101(2)이 저장
2. 프로그램을 처음부터 실행하기 위해 프로그램 카운터에는 1000이 저장됨. 이는 메모리에서 가져올 명령어가 1000번지에 있다는 것을 의미
3. 1000번지를 읽어 들이기 위해서는 주소 버스로 1000번지를 내보내야 함. 이를 위해 메모리 주소 레지스터에는 1000이 저장됨
4. ‘메모리 읽기’ 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내짐
5. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비 함
   1. 다음 명령어(1001번지). 프로그램 카운터는 지속적으로 증가하며 다음 명령어를 읽어 들일 준비를 함. CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행해 나갈 수 있는 이유
6. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동
7. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킴

### 범용 레지스터

- 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
- 데이터와 주소를 모두 저장할 수 있음
- 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있고, 대다수 CPU는 모두 범용 레지스터를 가지고 있음

### 플래그 레지스터

- 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

## 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식

스택 포인터: 스택 주소 지정방식에 사용

프로그램 카운터, 베이스 레지스터: 변위 주소 지정 방식에 사용

### 스택 주소 지정 방식

- 스택과 스택 포인터를 이용한 주소 지정 방식
- 스택은 가장 최근에 저장한 값부터 꺼낼 수 있음
- **스택 포인터**
  - 스택의 꼭대기를 가리키는 레지스터
  - 스택에서 마지막으로 저장한 값의 위치를 저장하는 레지스터
- 메모리 안에 스택처럼 사용할 영역이 정해져 있음 ⇒ 스택 영역

## 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식

### 변위 주소 지정 방식

- 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
- 변위 주소 지정 방식을 사용하는 명령어는 연산 코드 필드, 어떤 레지스터의 값과 더할지를 나타내는 레지스터 필드, 주소를 담고 있는 오퍼랜드 필드
  - 연산 코드: 이런 내용을 수행해라
  - 레지스터: 이 레지스터 값과
  - 오퍼랜드: 이 주소를 더한 곳에 있는 데이터로
- 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등으로 나뉨

### 상대 주소 지정 방식

- 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
- 프로그램 카운터에 읽어 들일 명령어의 주소 저장, 오퍼랜드가 -3이라면 CPU는 읽어 들이기로 한 명령어로부터 세번째 이전 번지로 접근
- if 문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용

### 베이스 레지스터 주소 지정 방식

- 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
- **베이스 레지스터**는 ‘기준 주소’, 오퍼랜드는 ‘기준 주소로부터 떨어진 거리’로서의 역할
- 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산해 유효 주소를 얻어내는 방식
- 베이스 레지스터에 200이라는 값이 있고, 오퍼랜드가 40이면 기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근하라는 뜻

---

# 04-3 명령어 사이클과 인터럽트

## 명령어 사이클

- 하나의 명령어를 처리하는 정형화된 흐름
- 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행됨
- 프로그램 속 각각의 명령어들은 명령어 사이클이 반복되며 실행됨

### 인출 사이클 fetch cycle

- 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 위의 실행과정에 2-6단계

### 실행 사이클 execution cycle

- CPU로 가져온 명령어를 실행하는 단계
- 제어 장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계

### 간접 사이클 indirect cycle

- 간접 주소 방식과 같이 명령어를 실행하기 위해 메모리 접근을 한 번 더 하는 단계

⇒ 어떤 명령어는 인출과 실행 사이클만으로 실행되고, 어떤 명령어는 인출, 간접, 실행 사이클을 거쳐 실행됨

## 인터럽트

- CPU의 정상적인 작업을 방해하는 신호

### 동기 인터럽트(예외)

- CPU에 의해 발생하는 인터럽트
- CPU가 명령어들을 수행하다가 예상치못한 상황에 마주쳤을 때, CPU가 실행하는 프로그래밍 상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트
- 이런 점에서 **예외** exception라고 부름

### 비동기 인터럽트(하드웨어 인터럽트)

- 주로 입출력 장치에 의해 발생하는 인터럽트
- 세탁기 완료 알림, 전자레인지 조리 완료 알림과 같은 역할
- 키보드, 마우스 같은 입출력 장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)을 보냄
- 하드웨어 인터럽트

### 하드웨어 인터럽트

- 알림과 같은 인터럽트
- CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 이런 알림과 같은 하드웨어 인터럽트 사용
- 하드웨어 인터럽트를 이용하면 CPU는 주기적으로 프린트 완료 여부를 확인할 필요가 없으므로 CPU는 인터럽트를 받을 때까지 다른 작업을 처리할 수 있음
- CPU로 하여금 효율적으로 명령어를 처리할 수 있게 함

### 하드웨어 인터럽트 처리 순서

1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보낸다
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다

- 인터럽트 요청 신호: CPU의 작업을 방해하는 인터럽트에 대한 요청
- 인터럽트 플래그: 하드웨어 인터럽트를 받아들일지, 무시할지 결정하는 플래그, 가능, 불가능으로 설정
  - 막을 수 있는 인터럽트
  - 막을 수 없는 인터럽트
- 인터럽트 서비스 루틴: 인터럽트를 처리하기 위한 프로그램 (= 인터럽트 핸들러)
  - CPU가 인터럽트를 처리한다 = 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 돌아온다
  - 인터럽트가 발생하면 어떻게 행동해야 할지를 알려주는 프로그램
- 인터럽트 벡터: 인터럽트 서비스 루틴을 식별하기 위한 정보
  - CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받음

CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업

그리고 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 인터럽트 서비스 루틴 실행

인터럽트 서비스 루틴을 모두 실행하면(인터럽트를 처리하고 나면) 스택에 저장해 둔 값을 다시 불러온 뒤 이전까지 수행하던 작업 재개
